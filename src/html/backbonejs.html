<!-- ********************* BACKBONE PRESENTATION 01/03 ********************** -->
<section>
	<h1>Tutoriel Backbonejs</h1>
	<img class="logo" src="http://arcane-refuge-8744.herokuapp.com/img/backbone-300x300.png">
	<p>
		<small>Created by <a href="#">Antonio Pierro</a> / <a href="http://twitter.com/antonio_pierro_">@antonio_pierro_</a></small>
	</p>
</section>
<!-- MVC Framework -->
<section>
	<section>
	<h2>What Is MVC?</h2>
		<ul>
			<li>MVC is a software architecture which consists of separation of model, view and controller.</li>
			<li>The model could be a database, or any number of data structures or storage systems.</li>
			<li>The view provides the user interface element of the application.</li>
			<li>The controller receives user input and makes calls to model objects and the view to perform appropriate actions.
			<li>This paradigm suggests to avoid mixing code from the three categories into one class.</li>
			</li>
		</ul>
		<aside class="notes"><h2>Qu'est-ce que MVC?</h2>
		<ul>
			<li>MVC de l'anglais model-view-controller</li>
			<li>Ce paradigme regroupe les fonctions nécessaires en trois catégories :</li>
			<ol>
				<li>un modèle (modèle de données)</li>
				<li>une vue (présentation, interface utilisateur)</li>
				<li>un contrôleur (logique de contrôle, gestion des événements, synchronisation)</li>
			</ol>
		</ul></aside>
	</section>

	<section><h2>What does MVC give us?</h2>
<ul>
	<li>Easier overall maintenance. When updates need to be made to the application it is clear whether the changes are data-centric or merely visual, meaning changes to views.</li>
	<li>This modularity allows developers responsible for core logic and developers working on the user-interfaces to work simultaneously</li>
</ul>
	</section>

	<section><h2>Exercise 1: create your first MVC app</h2>
<ul>
	Create the following three objects:
	<li>Controller (C): it listens on some kind of interaction/event stream.</li>
	<li>Model (M): it could be a simple string</li>
	<li>View (V): it has a method (render) able to show the data from the Model.</li>
</ul>
<aside class="notes">
<ul>
	<li>the View knows nothing about the Model apart from it implements some interface</li>
	<li>the Model knows nothing of the View and the Controller</li>
	<li>the Controller knows about both the Model and the View and tells the View to go do something with the data from the Model.</li>
</ul>
</aside>
	</section>

	<section>
		<h2>Exercise 1: solution</h2>
		<pre><code>var M = {}, V = {}, C = {};

M.data = "Bonjour tout le monde";

V.render = function (M) { alert(M.data); }

C.handleOnload = function () { V.render(M); }

window.onmousedown = C.handleOnLoad;</code></pre>
	</section>



</section>

<section>
    <section><h2>MV* framework for client-facing JavaScrip</h2>
    	<ul>
    		<li>Backbone.js</li>
    		<li>Angular.js</li>
    		<li>Ember</li>
    		<li>Spine</li>
    		<li>CANjs</li>
    		<li>JavaScriptMVC</li>
    	</ul>
    </section>

	<section>
		<h2>What is Backbonejs?</h2>
		<ul>
			<li><em>BackboneJS</em> is a Model-View-Controller (MVC) framework for client-facing JavaScript.</li>
			<li>Backbone aims to solve the code coupling problem by providing a model-view framework with templates that separate programming concerns</li>
			<li>It isn't possible to talk about Backbone without also discussing Underscore.js, Backbone’s prerequisite helper library.</li>
		</ul>
	</section>
	<section>
		<h2>Backbone & Underscore</h2>
		<ul>
			<li>Underscore, a library of useful functions:</li>
			<pre><code>// On collections:
_.each(coll, iterator); _.find(coll, iterator); // etc
// On arrays
_.flatten(arr), _.union(*arrs), _.uniq(arr), // etc
// On functions
_.bind(func, obj), _.throttle(func, wait), _.debounce(func, wait, true) // etc</code></pre>
		
		<li>All collection functions work on <a href="http://backbonejs.org/docs/backbone.html#section-112">Backbone.Collections</a>:<pre><code>BackboneCollection.each(iterator);
BackboneCollection.find(iterator);
// etc</code></pre><pre><code>bookCollection.each(function(book) {
  console.log(book.get("title"));
});</code></pre></li></ul>
		<aside class="notes">
		<pre>
			<code>
				var foo_t = _.throttle(function () {
					console.log(Date.now())
					}, 1500);
				foo_t(); foo_t();

				var foo_d = _.debounce(function () {
					console.log(Date.now())
					}, 1500)
				foo_d(); foo_d();
			</code>
		</pre>
		http://jsfiddle.net/amyseqmedia/dD99u/37/
		</aside>
	</section>

</section>

<section>

<section><h2>When Do I Need BackboneJS?</h2>
<ul>
	<li>When building a single-page application using JavaScript 
	and you want to reduce the number of HTTP requests required for new Views.</li>
	<li>If you're writing an application where most of the view rendering and data manipulation occurs in the browser. (Examples: GMail and Google Drive)</li>
</ul>

<aside class="notes"><h2>Quand utiliser Backbone.js</h2>
	<ul>
		<li>Backbonejs est un excellent choix pour les applications dites «single page application», c’est à dire une page principale avec un nombre important d’interactions utilisateur.</li>
		<li>Le code créé avec Backbone.js peut être testé via jasmine.</li>
	</ul>
	<ul>
	<li><em>gmail - google drive</em> These types of applications typically download a single payload containing all the scripts, 
	stylesheets and markup users need for common tasks and then perform a lot of additional behavior in the background. 
	For instance, 
	it's trivial to switch between reading an email or document to writing one and a new page is never requested from the server.</li>
</ul></aside>

</section>

<section><h2>Backbone’s main benefits</h2>
<ul>
	<li>Organize the structure to your application</li>
	<li>Simplify server-side persistence</li>
	<li>Decouple the DOM from your page’s data</li>
	<li>Model data, views and routers in a succinct manner</li>
	<li>Provide DOM, model and collection synchronization</li>
</ul>
<aside class="notes"><ul>
	<li>Découper les parties de vos application en vues qui géreront toute la logique de ces parties, la maintenance est beaucoup plus rapide par la suite.

Délimiter facilement plusieurs états dans votre application grâce au routeur.

Créer des vues qui écoutent sur ces modèles et qui se mettent à jour automatiquement si les modèles changent.</li>
</ul></aside>
</section>

</section>




<!-- ******************************************************************************
******************************** THE BACKBONE MODEL ******************************** 
****************************************************************************** !-->
<section>
	<section><h2>Backbone Model</h2>
	<ul>
		<li>Backbone model contains data as key/value pair
<pre><code>{
    "title": "my title", 
    "completed": true
}
</code></pre>
		</li>
		<li>Backbone model contains the logic around this data: 
		conversions, validations, computed properties, and access control.
<pre><code>task.set({completed: false});
task.get('completed'); // false</code></pre>
</li>

	</ul>
	<aside class="notes">
		<h2>Définition du modèle</h2>
		<ul>
			<li>Contient les données d’un objet – associations clés/valeurs.</li>
			<li>Les modèles sont responsables de la logique métier (business logic) et peuvent également servir pour la persistance, aussi bien locale avec localStorage que distante via des API RESTful en JSON.</li>
			<li>Les modèles proposent des enregistrements clé‐valeur et des événements associés.</li>
		</ul>

	        A common misconception is that the DOM is a part of the JavaScript language. It isn’t. In fact, it is a completely separate API that JavaScript interacts with. Having the ability to query the current “state” of your application without always resorting to querying the DOM is a HUGE WIN.
	        </aside>
	</section>
	<section>
		<h2>Backbone Model: creation</h2>
		<ul>
			<li>Models can be created by extending Backbone.Model as follows:
		<pre><code>var MyModel = Backbone.Model.extend({});</code></pre>
		</li>
			<li> We can then create our own concrete instance of a (MyModel) model with no values at all:
				<pre><code>var myModel1 = new MyModel();
console.log(myModel1);
// or with some arbitrary data:
var myModel1 = new MyModel({
     title: 'my first title model', 
     completed: true
});</code></pre>
			</li>
		</ul>
		<aside class="notes">extend sets up the prototype chain</aside>
	</section>
	<section>
		<h2>Backbone Model: creation: Initialization</h2>
		<ul>
			<li>The initialize() method is called when a new instance of a model is created. Its use is optional, however you’ll see why it’s good practice to use it below:
			<pre><code>var MyModel = Backbone.Model.extend({ 
	initialize: function(){
         console.log('This model has been initialized.'); 
     }
});
var myModel = new MyModel();</code></pre></li>
		</ul>
	</section>
	<section>
		<h2>Backbone Model: Default values</h2>
		<ul>
		<li>
			There are times when you want your model to have a set of default values (e.g. in a scenario where a complete set of data isn’t provided by the user):
			<pre><code>var MyModel = Backbone.Model.extend({
     defaults: {
         'title': '',
         'completed': false
     }
});</code></pre>
		</li>
		</ul>
	</section>
	<section>
		<h2>Backbone Model: Getters & Setters</h2>
		<ul><li>Model.get() provides easy access to a model’s attributes.
		<pre><code>myModel.get('title');
myModel.toJSON() // get all of a model’s data attributes </code></pre>
		</li>
		<li>Model.set() allows us to pass attributes into an instance of our model:
		<pre><code>myModel.set("title", "My new title."); 
console.log('myModel title: ' + myModel.get('title'));</code></pre></li></ul></section>
		<section><h2>Backbone Model: Listening for changes to your model</h2>
		<ul><li>All attributes of a model can have listeners bound to them which detect when their values change:
		<pre><code>var MyModel = Backbone.Model.extend({
     initialize: function() {
         this.on('change', function() {
             console.log('Values for this model have changed.');
         });
     }
});</code></pre>
		<pre><code>var MyModel = Backbone.Model.extend({
     initialize: function() {
         this.on('change:name', function() {
             console.log('Value name for this model have changed.');
         });
     }
});</code></pre>
		</li></ul>
	</section>

	<section>
		<h2>Backbone Model: Validation</h2><ul><li>
		Backbone supports model validation which allows checking the attribute values for a model prior to them being set.<pre><code>var MyModel = Backbone.Model.extend({  
     validate: function(attribs, options) {
         if(attribs.title === undefined) {
             return "Remember to set a title for your todo.";
         } 
     }
});</code></pre>
		 <aside class="notes">
		 <ul>
		 	<li>By default validate is called before save, but can also be called before set if {validate:true} is passed.</li>
		 	<li>Backbone passes the attributes object (attribs param in above example) by shallow copy to the validate function using the Underscore _.extend method. This means that it is not possible to change any Number, String or Boolean attribute but it is possible to change attributes of objects because they are passed by reference. As shallow copy doesn’t copy objects by implicitly copying them, but rather, by reference, one can change the attributes on those objects.
		An example of this (by @fivetanley) is available <a target="_" href="http://jsfiddle.net/2NdDY/7/">here</a>.
		 	</li>
		 </ul> </aside>
		</li></ul>
	</section>
	<section><h2>Backbone Model: Exercice 1</h2>
	<ul><li>Create a javascript object</li> 
	<li>Convert it to a model in backbone.</li></ul></section>
	<section><h2>Backbone Model: Solution 1</h2>
<pre><code>var your_object = {familyLogin: 'userLogin1', login: 'eg'}

var YourModel = Backbone.Model.extend();

var your_model = new YourModel(your_object);
</code></pre>
	</section>

	<section><h2>Backbone Model: Exercice 2</h2>
<ul>
	<li>Extend the Backbone.Model with a function able to iterate on the model attributes and change value for some condition.</li>
	<li>For exemple if the attributes model is the following: 
	<pre><code>{name:'Antonio', age: 36, over_18: null}</code></pre> 
	it should be able to change it in 
	<pre><code>{name:'Antonio', age: 36, over_18: true}</code></pre></li>
</ul>
	</section>

	<section><h2>Backbone Model: Solution 2</h2>
<pre><code>var MyModel = Backbone.Model.extend({
    initialize: function(attr) {
        this.set({over_18: false});
    	if(attr.age > 18) {
    		this.set({over_18: true});
    	}
    }
});
var myModel = new MyModel({name:'Antonio', age: 36, over_18: null});
</code></pre>
	</section>
</section>

<!-- ******************************************************************************
******************************* Backbone Backend *******************************
******************************************************************************-->

<section>
<section>
	<h2>The Backbone Backend</h2>
	<ul>
	<li>Backbone.sync is the function that Backbone calls every time it attempts 
	to read or save a model to the server. </li>
	<li>The sync method is called with three parameters:
	<ul>
		<li>method: One of create, update, delete, read</li>
		<li>model: The Backbone model object</li>
		<li>options: May include success and error methods</li>
		</ul>
	</li>
	</ul>


</section>


<section><h2>The Backbone Backend: (Model)</h2>
	<pre><code>var BookModel = Backbone.Model.extend(
  urlRoot: "/api/books",
  // ...
});

var book = new BookModel({id: 12});
book.fetch();</code></pre>

<pre><code>HTTP GET /api/books/12
{id: 12,
 title: 'Robot Dreams',
 author: 'Isaac Asimov',
 owned: false
}</code></pre>
<pre><code>book.markAsOwned();
book.save();</code></pre>
<pre><code>HTTP PUT /api/books/12
{id: 12,
 title: 'Robot Dreams',
 author: 'Isaac Asimov',
 owned: true
}</code></pre></li></ul>
	<aside class="notes">By default, it uses jQuery.ajax to make a RESTful JSON request and returns a jqXHR. You can override it in order to use a different persistence strategy, such as WebSockets, XML transport, or Local Storage.</aside>
</section>

<section>
	<h2>The Backbone Backend: (Collection)</h2>
	<pre><code>var BookCollection = Backbone.Collection.extend({
  url: "/api/books",
  // ...
});</code></pre>
<pre><code>var myBooks = new BookCollection();
myBooks.fetch();</code></pre>
<pre><code>HTTP GET /api/books
[{id: 12,
 title: 'The Naked Sun',
 author: 'Isaac Asimov'
}, ...
]</code></pre>
<pre><code>myBooks.create(new BookModel({title: 'Foundation',
                         author: 'Isaac Asimov'}));

                         HTTP POST /api/books
{title: 'Foundation', author: 'Isaac Asimov'}</code></pre>
<aside class="notes"><pre><code>    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'</code></pre></aside>
</section>

<section>
	<h2>Override Backbone.sync</h2>
	<ul>
		<li>You can override this function to change the manner in which Backbone persists models to the server. </li>
		<li>There are quite a few sync implementations out there:
		<ul>
			<li>Backbone localStorage</li>
			<li>Backbone offline</li>
			<li>Backbone Redis</li>
			<li>backbone-parse</li>
			<li>backbone-websql</li>
			<li>Backbone Caching Sync</li>
		</ul></li>
	</ul>
</section>

<section><h2>localStorage usage</h2>
<ul>
	<li>Include Backbone.localStorage after having included jQuery and Backbone.js:
	<pre><code>&lt;script type="text/javascript" src="jquery.js">&lt;/script>
&lt;script type="text/javascript" src="backbone.js">&lt;/script>
&lt;script type="text/javascript" src="backbone.localStorage.js">&lt;/script></code></pre></li>
<li>Create your model like so:<pre><code>var SomeModel = Backbone.Model.extend({

  localStorage: new Backbone.LocalStorage("SomeCollection"), // Unique name within your app.

  // ... everything else is normal.

});</code></pre></li>
</ul></section>


	<section><h2>Backbone Model: Exercice 1</h2>
	<ul>
		<li>Write a task model with the following feature:
		<ul>
			<li>having two attributes: title (string) and completed (boolean)</li>
			<li>save all of the task items under the `"tasks"` namespace by using Backbone.LocalStorage</li>
			<li>have a method wich is able to toggle the "completed" state of this task item.</li>
		</ul></li>
		<li>How should it work:
		<pre><code>task.attributes; //{title: "", completed: false}
task.toggle();
task.attributes; //{title: "", completed: true}</code></pre></li>
	</ul></section>

		<section><h2>Backbone Model: Solution 1</h2>
		<pre><code>Task = Backbone.Model.extend({
    defaults: {
        title: '',
        completed: false 
    },

    localStorage: new Backbone.LocalStorage('tasks-backbone'),

    toggle: function() { 
        this.set({
            completed: !this.get('completed') 
        });
    } 
});</code></pre>
	</section>
</section>

<!-- 
****************************************************************************
**************** THE BACKBONE COLLECTION ***************************************
****************************************************************************
 !-->
<section>
<section>
<h2>Backbone collection</h2>
<ul>
<li>Collections are ordered sets of models.</li>
<li>When creating a collection you need to pass through a property specifying the model that your collection will contain.</li>
<li>A collection can also contain polymorphic models by overriding this property with a constructor that returns a model.</li>
</ul>

<aside class="notes"><ul><li>Les collections offrent un catalogue bien pratique de méthodes d’énumération: ce sont les méthodes map, reduce, filter importées depuis underscore.js</li>
<li>underscore.js est une des rares dépendances de Backbone.js</li>
</ul>

	<aside class="notes">
<pre><code>var Library = Backbone.Collection.extend({

  model: function(attrs, options) {
    if (condition) {
      return new PublicDocument(attrs, options);
    } else {
      return new PrivateDocument(attrs, options);
    }
  }

});</code></pre>
	</aside>
</aside>
</section>

<section>
<h2>Backbone collection: creation</h2>
<ul>
	<li>In the following example, we create a TaskCollection that will contain our Task model:
		<pre><code>var TaskCollection = Backbone.Collection.extend({
			model: myModel
});

var taskCollection = new TaskCollection();

console.log(taskCollection);
</code></pre>
	</li>
</ul>
	
	<aside class="notes"><h2>Backbone collection: création</h2>
	<ul><li>On suppose d'avoir déjà défini un modèle MyModel</li>
		<li>la collection peut être créés par:<pre><code>var MyCollection = Backbone.Collection.extend({
			model: myModel
});
var myCollection = new MyCollection();
console.log(myCollection);
</code></pre></li>
	</ul></aside>
</section>

<section><h2>Backbone collection: Getters and Setters</h2>
<ul>
<li>Collection.get() accepts a single id as follows:<pre><code>var myModel2 = myCollection.get(2);</code></pre></li>
<li>Backbone Collections don't have setters as such, <br>
	but do support adding new models via <strong>.add()</strong><br>
	and removing models via <strong>.remove()</strong>.</li>
</ul>
</section>

<section><h2>Backbone collection: reset</h2>
<ul>
<li>Rather than adding or removing models individually, <br>
	you might occasionally wish to update an entire collection at once:
	<pre><code>myCollection.add([
     { title: 'go to Jamaica.', completed: false }, 
     { title: 'go to China.', completed: false },
     { title: 'go to Disneyland.', completed: true }
]);
console.log('Collection size: ' + myCollection.length);
myCollection.reset([
     { title: 'go to Cuba.', completed: false }
]);
console.log('Collection size: ' + myCollection.length);</code></pre></li>
<li>Calling collection.reset() without passing any models as arguments will empty the entire collection</li>
</ul>
</section>

<section><h2>Backbone collection: forEach et sortBy()</h2>
<ul>
<li><strong>forEach</strong> method can be used for iterating over collection:<pre><code>TodosCollection.forEach(function(model){ 
	console.log(model.get('title'));
});
</code></pre></li>
<li><strong>sortBy()</strong> method that can be used to sort a collection of todos based on a particular attribute:<pre><code>var sortedByAlphabet = TodosCollection.sortBy(function (todo) {
     return todo.get("title").toLowerCase();
});</code></pre></li>
</ul>
</section>

<!--
<section><h2>Backbone collection: Excercise 1</h2>
<ul>
<li>Explain what is the difference betwwen these two codes and why the first one is broken:
<pre><code>// code 1
var MyCollection = new Backbone.Collection.extend({
     model: MyModel
});</code></pre>
<pre><code>// code 2
var MyCollection = Backbone.Collection.extend({
     model: MyModel
});</code></pre></li>
<li>you can look the annotated source code (http://backbonejs.org/docs/backbone.html)</li>
</ul>
<aside class="notes">
	if you run the following
	<code>var myCollection = new MyCollection()</code>
	you get: TypeError: Object [object Object] has no method 'apply'
</aside>
</section>


<section><h2>Backbone collection: Solution 1</h2>
<ul><li>In Backbone.js we have:<pre><code>var extend = function(protoProps, staticProps) {

    var parent = this;
    var child;

    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }
.....
    </code></pre></li>
<li>If you instantiate Backbone.Collection.extend with the new operator, then "parent" 
  will refer to the extend object
  <li>If you don't use new operator, then "parent"
will refer to Backbone.Collection and since you can only call .apply on functions, the code will break.</li>
    </ul></section>
-->

    	<section><h2>Backbone Collection: Exercice 2</h2>
	<ul>
		<li>Write a task coleection with the following feature:
		<ul>
			<li>is backed by *localStorage* instead of a remote server.</li>
			<li>Have a reference to a Backbone.Model.</li>
			<li>Have a method wich is able to filter down the list of all tasks that are finished.</li>
			<li>Have a method wich is able to filter down the list of all tasks that are still not finished.</li>
		</ul></li>
		<li>How should it work:
		<pre><code>var tasks = new Tasks([
  {name: "first", completed: true},
  {name: "second", completed: false},
  {name: "third", completed: true}
]);

(tasks.completed()).length // 2 
(tasks.remaining()).length // 1</code></pre></li>
<li>
	Hints: see the <a href="http://backbonejs.org/#Collection-Underscore-Methods">Underscore Methods (28)</a>
</li>
	</ul></section>

		<section><h2>Backbone Collection: Solution 2</h2>
		<pre><code>var Tasks = Backbone.Collection.extend({

	model: Task,

	localStorage: new Backbone.LocalStorage('tasks-backbone'),

	completed: function() {
		return this.filter(function( task ) {
			return task.get('completed'); });
	},
    
	remaining: function() {
		return this.without.apply( this, this.completed() );
	},
});</code></pre>
	</section>

</section>


<!-- 
****************************************************************************
**************** THE BACKBONE EVENTS ***************************************
****************************************************************************
 !-->

 <section>
 	<section><h2>Backbone Events</h2>
 	<ul>
 		<li>Backbone.Events is mixed into the other Backbone "classes", including:
 			<ul>
 				<li>Backbone.Model</li>
 				<li>Backbone.Collection</li>
 				<li>Backbone.Router</li>
 				<li>Backbone.History</li>
 				<li>Backbone.View</li>
 			</ul>
 		</li>
 	</ul>
<aside class="notes">Observer pattern (nowadays commonly implemented as a Publish/Subscribe system) </aside>
 	</section>
 	<section><h2>Mix Backbone.Events into any object </h2>
 		<ul>
 			<li>Backbone.Events also has the ability to give any object 
 	a way to bind and trigger custom events<pre><code>var ourObject = {}; 
// Mixin
_.extend(ourObject, Backbone.Events);

function dancing (msg) { 
     console.log("We started " + msg); 
}
// Add namespaced custom events
ourObject.on("dance:tap", dancing); ourObject.on("dance:break", dancing);
// Trigger the custom events
ourObject.trigger("dance:tap", "tap dancing. Yeah!"); 
ourObject.trigger("dance:break", "break dancing. Yeah!");

// Removes event bound to the object
ourObject.off("dance:tap");

// Passing multiple arguments to multiple events
ourObject.trigger("dance jump skip", {duration: "15 minutes", action: 'on fire'});</code></pre></li>
 		</ul>
 		<aside class="notes">_.extend(destination, *sources) <br>
Copy all of the properties in the source objects over to the destination object, and return the destination object. It's in-order, so the last source will override properties of the same name in previous arguments.
<pre><code>_.extend({name: 'moe'}, {age: 50});
=> {name: 'moe', age: 50}</code></pre>
</aside>
 	</section>
 </section>

<!-- **************** THE BACKBONE VIEW ******************** !-->
<section>

	<section>
		<h2>Backbone View</h2>
		<ul>
			<li>Views represent a display of data within a model, usually providing different information depending upon the context needed.</li>
			<li>Views in Backbone don’t contain the markup for your application, but rather they are there to support models by defining the logic for how they should be represented to the user. (This is usually achieved using JavaScript templating (e.g. Mustache, jQuery-tmpl, etc.).)</li>
		</ul>
		<aside class="notes"><ul>
		<li>Les vues font la liaison entre les modèles et le DOM. </li>
		<li>Elles mettent à jour le code HTML en fonction des modifications des modèles et, dans l’autre sens, peuvent gérer les événements du DOM;</li>
		</ul></aside>
	</section>


<section>
	<h2>Creating new views</h2>
	<ul>
		<li>To create a new View, simply extend Backbone.View</li>
		<pre><code>var MyView = Backbone.View.extend({});

var myView = new MyView();

console.log(myView.el);</code></pre>
	<li>What is el? el is basically a reference to a DOM element and all views must have one. </li>
	</ul>
	<aside class="notes">	<h2>Vue en détail: création</h2>
	<ul><li>Les Vues peuvent être créés par:<pre><code>var MyView = Backbone.View.extend({
});
var myView = new MyView();
console.log(myView.el);
	</code></pre></li>
	<li><strong>el</strong> is basically a reference to a DOM element and all views must have one.</li></ul></aside>
</section>

	<section>
		<h2>Backbone & jQuery</h2>
		<ul>
			<li>Standalone jQuery:<pre><code>$('body').append('<br>');
$('.course-list').html('Best Course Ever');</code></pre></li>
<li>Every Backbone.View has a $el and a $() method:<pre><code>var View = Backbone.View.extend({
   el: 'body',
   render: function() {
    
     this.$el.append('<br>');
     this.$el.find('.coursera-listing').html('Best Course Ever');
     // or shorter:
     this.$('.coursera-listing').html('Best Course Ever');
   }
})</code></pre></li>
		</ul>
		<aside class="notes"> jQuery, Zepto, Ender<pre><code>view.$
function (selector) {
      return this.$el.find(selector);
    }</code></pre></aside>
	</section>

		<section>
		<h2>"Bonjour tout le monde" en modèle Backbone.js</h2>
		<pre><code>(function($){
     var AppView = Backbone.View.extend({    
         el: $('body'),
         render: function(){
             $(this.el).append("Bonjour tout le monde");
         },
         initialize: function(){
             _.bindAll(this, 'render');           
             this.render();
         },
     });
     var appView = new AppView();      
 })(jQuery);</code></pre>
	</section>

<section>
<h2>Backbone View: tagName, id and className</h2>
<ul><li>If you want to create a new element for your view,<br>set any combination of the following view’s properties: <br>tagName, id and className<pre>
<code>var MyView = Backbone.View.extend({
     tagName: 'ul', // required, but defaults to 'div' if not set
     className: 'container', // optional
     id: 'todos' // optional
});
var myView = new MyView();
console.log(myView.el);
</code>
</pre></li>
</section>

<section>
	<h2>Backbone View: template</h2>
	<ul>
		<li>
			It's convenient to define a template file to use on your view:s
<pre><code>//template file
<script type="text/template" id="form-tpl">
    <label>Name:</label>
    <input type="text" name="name" value="<%= name %>">
    <label>Age:</label>
    <input type="text" name="age" value="<%= age %>">
</script>
<div id="form"></div>
</code></pre>
<pre><code>var MyView = Backbone.View.extend({
     el: "#form",
     render: function() {
         var html = _.template($('#form-tpl').html(), {age:12, name:'ciao'});
         this.$el.html(html);
    }
});</code></pre>
</li>
<li>You can pass the model to the istance view:<pre><code>myView = new MyView({model: myModel});</code></pre></li>
	</ul>
</section>

<section>
	<h2>Mustache</h2>
	<ul>
		<li>Mustache is an HTML templating library. To use it:</li>
		<ul>
			<li>Make a template file:
			<pre><code>&lt;div id="id="book-template"">
     &lt;strong>{{ book.title }}&lt;/strong> 
     was written by {{ book.author }}
&lt;/div></code></pre>
			</li>
			<li>Compile the template and render it with your data:<pre><code>var source   = $("#book-template").html();
var template = Mustache.compile(source);
var myBook = {
     "title": "Robot Dreams", 
     "author": "Isaac Asimov"
};
var rendered = template({book: myBook});</code></pre></li>
		</ul>
	</ul>
</section>

<section>
	<h2>Backbone and Mustache</h2>
	<ul><li>The HTML file<pre><code>&lt;div id="books-template">
     {{#books}}
     <b>{{name}}</b>
     {{/books}}
&lt;/div></code></pre></li>
<li>In the JS view:<pre><code>var BookShelfView = Backbone.View.extend({
  render: function() {
    // Compile the template
    var template = Mustache.compile(
         $("#books-template").html());
    // Render the template with the current collection data
    var rendered = template({
         books: this.collection.toJSON()});
    // Append the rendered HTML to the current view's element
    this.$el.append(rendered);

    return this;
  }
});</code></pre></li></ul>
<aside class="notes"><pre><code>{
  "books": [
    { "name": "Moe" },
    { "name": "Larry" },
    { "name": "Curly" }
  ]
}</code></pre></aside>
</section>

<section>
	<h2>Models & Views</h2>
	<ul>
		<li>Putting them together:<pre><code>var booksJSON = [
     {title: 'I, Robot', author: 'Isaac Asimov'},
     {title: 'Robot Dreams', author: 'Isaac Asimov'}
];

var books = new BookCollection(booksJSON);

var view = new BookShelfView(
     {collection: books}
);

$('body').append(view.render().$el);</code></pre></li>
	</ul>
</section>

<section>
	<h2>Nested Views</h2>
	<ul><li>Book Item View:<pre><code>var BookItemView = Backbone.View.extend({
  className: 'book',
  tagName: 'li',
  render: function() {
    var bookLink = $('&lt;a>').attr('href', this.model.get('url'));
    var bookCover = $('&lt;img>').attr('src', this.model.get('thumbnail'));
    bookLink.append(bookCover);
    this.$el.append(bookLink);
    return this;
  }
});
var itemView = new BookItemView({model: bookModel});</code></pre>
</code></pre>
</li><li>Book List View:
<pre><code>var BookShelfView = Backbone.View.extend({
  className: 'books',
  tagName: 'ol',
  render: function(eventName) {
    this.collection.each(function (book) {
      var bookItemView = new BookItemView({model: book});
      this.$el.append(bookItemView.render().$el);
    }, this);
    return this;
  }
});

var shelfView = new BookShelfView({collection: bookCollection});</code></pre></li></ul>
<aside class="notes">ogni book concorder avec a div</aside>
</section>

<section><h2>Views + DOM Events</h2>
<ul><li>Set callbacks, where this.events is a hash of {"event selector": "callback"}<pre><code>var BookItemView = Backbone.View.extend({
  events: {
    'mouseover img': 'showReview',
    'mouseout img': 'hideReview'
  },
  hideReview: function() {
    this.$('.book-review').remove();
  }
});
</code></pre></li>
<li><a href="http://backbonejs.org/#Events-catalog">Backbone's built in events</a><pre><code>"add"    	when a model is added to a collection.
"remove" when a model is removed from a collection.
"reset"  when the collection's entire contents have been replaced.
"sort"   when the collection has been re-sorted.
"change:[attribute]" when a specific attribute has been updated.

MyCollection.on( 'add', callback, this );</code></pre></li>
</ul></section>

<section><h2>Backbone View: Exercice 1</h2>
<ul>
	<li>Create a web page that can be run directly in a web browser. <ul>
		<li>Before any coding can begin, the jQuery, Underscore, and Backbone libraries are included within the page’s head;</li>
	</ul></li>
	
	<li>Create a CertificateView class, which is a placeholder for a birth certificate (uses Backbone’s extend method to create a prototype chain)</li>
	<ul>
		<li>The view will have two custom functions: 
		<ul>
		<li><em>initialize</em>: Executed when a new instance of the view is created; in this case, the desire is for the view to render its contents immediately</li>
		<li><em>render</em>: Draws the contents of the view to the target element as described next. You specifically instruct the view to render itself inside the div whose ID is certificate</li>
		</ul>
		</li>
	</ul>
</ul>

	</section>
<section><h2>Backbone View: Solution 1</h2>
<pre><code>&lt;div id="certificate"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt; 
CertificateView = Backbone.View.extend({
    initialize: function() { 
    	this.render();
    },
    render: function() {
        $(this.el).html("&lt;h1&gt;Guy Incognito&lt;/h1&gt;&ls;p&gt;DOB: March 2, 1967&lt;/p&gt;");
    } 
});
var certificate_view = new CertificateView({ el: $("#certificate")}); 
</script></code></pre>
</section>



<section><h2>Backbone View: Exercice 2</h2>
<ul><li>Create a model and a view class.</li>
<li>Create an instance of model and view</li>
<li>Create a template</li>
<li>Use all together to create an app able to render the model in the view</li></ul></section>

<section><h2>Backbone View: <a target="_" href="http://jsfiddle.net/CX3ud/29/">Solution 2</a></h2>
<pre><code>&lt;script type="text/template" id="form-tpl"&gt;
    <label>Name:</label>
    <input type="text" name="name" value="<%= name %>">
    <label>Age:</label>
    <input type="text" name="age" value="<%= age %>">
&lt;/script&gt;
<div id="form"></div></code></pre>
<pre><code>var MyModel = Backbone.Model.extend({});
var MyView = Backbone.View.extend({
    el: "#form",
    render: function() {
        var html = _.template($('#form-tpl').html(), this.model.toJSON());
        this.$el.html(html);
    }
});

$(function() {
    var person = new MyModel({
        name: 'Thomas',
        age: 37
    }),
    app = new MyView({model: person});
    app.render();
});</code></pre>
</section>

<section>
	<h2>Backbone View: Exercice 3</h2><h3>Friend list app</h3>
	<ul>
		<li>Create a model to hold friend attribute</li>
		<li>Create a friends collection which holds our Friend models</li>
		<li>Create a View with is able to add a new friend model to our friend collection and display it on the web page</li>
	</ul>
</section>


<section>
	<h2>Backbone View: Solution 3</h2>
	<pre><code>&lt;body>
<input type="text" placeholder="Enter friend's name" id="input" />
<button id="add-input">Add Friend</button>
<ul id="friends-list">
</ul>
&lt;script type="text/javascript" src="test.js"></script>
&lt;/body></code></pre>

<pre><code>$(function() {
	var Friend = Backbone.Model.extend();

    var FriendList = Backbone.Collection.extend({
    	model: Friend
    });

    var FriendView = Backbone.View.extend({

        tagName: 'li',

        friendslist: new FriendList,

        events: {
            'click #add-input':  'getFriend',
        },

        initialize: function() {
            this.friendslist.on('add',this.render)
            _.bindAll(this, 'render');
        }, 

        getFriend: function() {
            var friend_name = $('#input').val();
            this.friendslist.add( {name: friend_name} );
        },

        render: function(model) {
            $("#friends-list").append("<li>"+ model.get("name")+"</li>");
            console.log('rendered');
        },

    });

    var view = new FriendView({el: 'body'});

});</code></pre>
</section>





</section>


<!-- 
****************************************************************************
**************** THE BACKBONE ROUTER ***************************************
****************************************************************************
 !-->
<section>
<section>
	<h2>Router</h2>
	<ul>
		<li>Routers are used to help manage application state and for connecting URLs to application events.</li>
		<li>Note the inline comments in the code example below as they continue the the lesson on routers.
		<pre><code>var MyRouter = Backbone.Router.extend({
    routes: { 
        "about" : "showAbout",
        /* Sample usage: http://example.com/#about */,

        "todo/:id" : "getTodo",
        /* This is an example of using a ":param" variable
         which allows us to match any of the components 
         between two URL slashes */
        /* Sample usage: http://example.com/#todo/5 */

        "*other" : "defaultRoute"
        /* This is a default route */
        /* Sample usage: http://example.com/#"anything" */

        showAbout: function(){ ... } ,
        ...
    }
});
		</code></pre></li>
	</ul>
</section>
<section><h2>Is there a limit to the number of routers I should be using?</h2>
<ul>
	<li>Usually you should use a single router in most of their applications.</li>
	<li>You’re very likely to not require more than one or two routers in your own projects; the majority of your application routing can be kept organized in a single router without it getting unwieldy.</li>
</ul></section>
</section>
</section>




<!--

<section>
<section>
	<h2>L’architecture du projet</h2>
	<p> Notre application devrait être découplée en plusieurs fichiers, en séparant modèle, vue etc…</p>
		<a href="#" class="image navigate-down">
			<img width="108" height="138" src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
		</a>
</section>
<section>
		<ul>
			<li>assets</li>
			<ul>
				<li>js</li>
			</ul>
			<li>src</li>
			<li>modules</li>
		</ul>
</section>
<section>
	<ul>
		<li><b>assets/</b>: répertoire regroupant la plupart des fichiers statiques, comme les fichiers CSS, les images ainsi que les srclibrairies JavaScripts (backbone.js, jquery.js et underscore.js)</li>
		<li><b>src/</b>: c’est le dossier de notre application Backbone.js, il va contenir tous les fichiers JavaScript propres à notre application. Le dossier modules/ regoupera les vues, le router, les collections et les models. </li>
	</ul>	
</section>
	<aside class="notes">
		Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
	</aside>

</section>

-->
<section>
	<section><h2>Exercise 1: task management app</h2><h3>Your First Backbone.js App</h3>
<ul>
	<li>Let's consider the application's architecture at a high level. We'll need:
	<ul>
		<li>a Task model to describe individual task items</li>
		<li>a TaskList collection to store and persist tasks</li>
		<li>a way of creating tasks</li>
		<li>a way to display a listing of tasks</li>
		<li>a way to edit existing tasks</li>
		<li>a way to deem a task complete</li>
		<li>a way to delete tasks</li>
		<li>a way to bookmark the tasks that have been completed or are remaining</li>
	</ul>
	</li>
</ul>
<aside class="notes">Now that we’ve covered fundamentals, let’s write our first Backbone.js application.</aside>
	</section>

<section><h2>Index</h2><ul>
	<li>First, we'll set up the basic application dependencies:
	<ul>
		<li>jQuery</li>
		<li>Underscore</li>
		<li>Backbone.js</li>
		<li>Backbone.LocalStorage</li>
	</ul>
	</ul>
	<aside class="notes">
Comme vous le pouvez le voir, le contenu html de notre application sera englobé dans une div avec l’id «content », c’est surtout pour éviter d’écraser l’insertion des librairies ou autres codes importants comme les templates. C’est donc le sélecteur $(‘#content’) que l’on utilisera pour initier la base de notre application. Ensuite on inclut toutes les librairies dont Backbone JS a besoin pour fonctionner, là rien de bien méchant, attention cependant, jQuery et underscore.js doivent être inclus avant backbone.js.
	</aside>
</section>

<section><h2>Application HTML</h2>
<ul>
	<li>Now let's take a look at our application's static HTML. We'll need an:</li>
	<ul>
		<li><u>&lt;input&gt;</u> for creating new tasks</li>
		<li><u>&lt;ul id="todo-list"&gt;</u> for listing the actual tasks and a section containing some operations, such as clearing completed tasks.</li>
	</ul>
</ul></section>

<section><h2>Todo model</h2>
	
</section>

</section>
				<!--SLIDE_3-->


<!--END SLIDE_3-->
<section>
<section><h2>DOM Storage</h2>
	<ul>
		<li>The DOM Storage mechanism is a means through which string key/value pairs can be securely stored and later retrieved for use.</li>
		<li>sessionStorage: is a global object (sessionStorage) that maintains a storage area that's available for the duration of the page session.</li>
		<li>localStorage: is the same as sessionStorage with same same-origin rules applied but it is persistent.</li>
	</ul>
</section>
<section><h2>Storage Interface</h2>
	<pre><code>interface Storage {
  [IndexGetter] DOMString key(in unsigned long index);
  [NameGetter] DOMString getItem(in DOMString key);
  [NameSetter] void setItem(in DOMString key, in DOMString data);
  [NameDeleter] void removeItem(in DOMString key);
  void clear();
};</code></pre>
<aside class="notes">For Java and ECMAScript, 
DOMString is bound to the String type because both languages also use UTF-16 as their encoding.</aside>
</section>
	
</section>

<section>
	<section>
	<h2>GitHub 1/2</h2>
	<ul>
		<li>Sets up the necessary Git files:
		<pre><code>
cd ~/Sites
mkdir DEV1Ecole
cd DEV1Ecole
git init
git remote add origin git@github.com:DEV1Ecole/Backbone.git
			</code></pre>
		<li>Create, coommit and push to your repository:
			<pre><code>
touch votre_nom.txt
git add votre_nom.txt
git commit -m"mon première commit"
git push origin master
			</code></pre>
		</li>

		</li>
	</ul>
</section>
<section>
	<h2>GitHub 2/2</h2>
	<ul>
		<li>Delete a file from your repository:
			<pre><code>
rm votre_nom.txt
git add votre_nom.txt
git commit -m"delete mon première file"
git push origin master
			</code></pre>
		</li>
		<li>What if you realize that you don't want to keep your changes to the your_file.txt file? :
		<pre><code>
git checkout your_file.txt
		</code></pre></li>
	</ul>
</section>
</section>


<section>
	<h3>References</h3>
	<p>
		<ul>
			<li><a href="https://github.com/ccoenraets/directory-backbone-bootstrap">Sample Application built with Backbone.js and Twitter Bootstrap</a></li>
			<li><a href="http://www.teaching-materials.org/backbone/">GETTING STARTED WITH BACKBONE</a></li>
			<li><a target="_" href="http://linuxfr.org/news/d%C3%A9couvrez-backbonejs%C2%A0050-pour-organiser-votre-code-javascript">Découvrez Backbone.js 0.5.0 pour organiser votre code JavaScript</a></li>
			<li><a target="_" href="http://www.atinux.fr/2011/12/10/organiser-son-code-backbone-js-en-modules/">Organiser son code Backbone JS en modules</a></li>
			<li><a target="_" href="http://blog.keiruaprod.fr/2012/05/08/intro-a-backbone-js-1-les-vues/">Intro à Backbone.js – #1 : les vues</a></li>
			<li><a target="_" href="http://fr.clever-age.com/veille/blog/decouvrir-backbone-js-avec-todomvc.html">Découvrir Backbone.js au travers de l’application TodoMVC</a></li>
			<li><a target="_" href="http://www.rvl.io/mindelusions/backbonejs">backbonejs on reveal.js</a></li>
			<li><a href="http://backbone.codeschool.com/levels/1/challenges/5">backbone.codeschool</a></li>
			<li><a href="https://github.com/k33g/articles/blob/master/2011-07-19-BACKBONE.md">MON 1ER TUTO BACKBONE.JS</a></li>
		</ul>
	</p>
</section>
</section>

